---
layout: post
title: "Read &lt;&lt;Linux-and-the-Unix-Philosophy>>"
date: 2013-04-23
comments: true
categories: blog
tags: [Reading] 
---
**学习中......**<br/><br/>
**读后感**<br/>
TODO<br/><br/>
**要点**<br/>

* NIH综合症<br/>
看到这个词，让我很惊讶，这不是在说我吗？不可能，他又不认识我。看来得NIH综合症的人不少呀！<br/>
细想一下，NIH综合征确实要不得，首先自己不是绝顶聪明的人，自己做出来的东西很难超越其他人的东西，既然这样，那何必要自己重新做一遍呢！倒不如直接使用已有的东西，从中学习和研究，并且找到改良的地方，来满足自己的需求。直到你有足够的经验，了解前人遇到的困难，能够“取其精华，去其糟粕”，这时候再提出自己的方案，这样不是更好吗。<br/><br/>
* 小即是美<br/>
我很同意这个观点，但是怎么样的大小才算"小"？这个比较难把握。<br/>
小的尺度很难把握，但是我们却可以通过这样的方法来保证我们的程序尽可能小：一个程序只做一件事情，一个功能只做一件事情，一个类只做一件事情，一个函数只做一件事情。
<br/><br/>
* 一个程序只做好一件事情<br>
“一个程序只做好一件事情“应该是”小即是美“的一种具体做法了。很同意这种原则。<br/>
* 尽快建立原型<br/>
尽快建立原型确实好处多多，因为它可以直观的验证你的想法，并且其他人也可以直观的看到你的想法。<br/>
这里有一个问题：是不是所有的程序都能快速的建立原型？如果不可以的话，有什么好办法？<br/>
对于有些比较难的功能(特别是那些前瞻性的，研究性质的功能),想要快速建立原型，有时候是不大可能完成的，面对这样的功能，你只能“慢慢”来了。<br/>
* 人类创造的“三个系统”<br/>
人类的系统设计可以类比人的三个生命阶段：未成年，成年和老年。<br/>
* 可移植性比高性能的优先级更高<br/>
作者提出的观点是：机器的性能越来越高，同时机器的更新换代越越来越快，如果你的程序的移植性很差，那么你的程序将无法存活下来，相反，如果你的程序移植性很高，虽然性能差一些，但是在新的机器中可以袮补你目前的低性能。<br/>
* 采用纯文本文件来存储数据<br/>
这个观点是基于“可移植性优先级更高”的原则提出来的，文本文件的性能会比较差，但是移植性是一级棒的。<br/>
* 充分利用软件的杠杆效应<br/>
该原则说的就是我们应该避免NIH综合症，尽可能的使用已经存在的程序。同时你也应该允许其他人使用你的程序来发挥杠杆效应。<br/>
* 使用shell脚本来提高杠杆效应和可移植性<br/>
* 避免强制性的用户界面<br/>
我无法理解该原则，对于一个普通用户来说，谁会去学习这么多的命令呀，谁又能记住那么多命令。不怪的Unix和Linux的普通用户的数量远远比不上Windows。<br/>
* 让每一个程序都成为过滤器<br/>
* 允许用户定制环境<br/>
* 尽量是操作系统内核小而轻量化<br/>
* 使用小写字母并尽量简单<br/>
我不同意，该原则已经不大适用了，我觉得应该是该大写的就大写，该长的就长，不要吝啬那几个字母。
* 保护树木
* 沉默是金<br/>
这是我无法忍受的原则。你的沉默就以为着我的痛苦，往往我需要痛苦的研究你为什么这么沉默。<br/>
* 并行思考<br/>
* 各部分之和大于整体<br/>
* 寻求90%的解决方案<br/>
* 更坏就是更好<br/>
* 层次化思考<br/>

---

引用<br/>
1. &lt;&lt;Linux/Unix 设计思想&gt;&gt;<br/>
