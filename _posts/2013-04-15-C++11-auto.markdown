---
layout: post
title: "C++11 -- auto"
date: 2013-04-15
comments: true
categories: blog
tags: [C++, C++11] 
---
<em>学习中......</em>

<p>关键字auto的定义在C++11标准中做了重新定义，并且C++98的定义不再支持。</p>
<em>C++11之前</em>：用于定义本地变量。在新的标准中如果定义这样的变量<br/>
<code>auto int var</code><br/>
将会引起一个编译错误。<br/>
<em>C++11</em>：允许编译器来推导一个变量的类型，而开发人员不再需要显式的指定变量类型，例如：<br/>
<code>
int num = 7;//显式指定变量num的类型<br/>
auto num = 7;//由编译器来推导num的类型，由于7是一个整型，所以num会被自动推导为int类型<br/>
auto p = new auto(1);//由编译器来推导p的类型，由于1是一个整形，所以p会被自动推导为int类型<br/>
</code>

auto的新语法给开发人员带来极大的方便，主要表现如下:
<ul>
<li><p>不再需要书写冗长的类型名字，特别是在使用模板的时候。例如:<br/>
<code>
template&lt;typename T>
void print(const vector&lt;T>& v){<br/>
for(auto p = v.begin(); p!= v.end(); ++p){<br/>
cout &lt;&lt; *p &lt;&lt; "\n";
	<br/>}	
<br/>}
</code>
</p></li> 
<li><p>对于变量类型依赖于模板参数的情况，有些时候很难明确写出具体类型，那么使用auto就会很方便。例如:<br/>
<code>
template&lt;typename T>
void test(const vector&lt;T>& v, const vector&lt;T>& u){<br/>
...<br/>
auto tmp = v[i]*u[i];<br/>
...
<br/>}
</code>
</p></li>
<li>
<p>
支持late-specified return types, 即延迟推导函数返回类型，对于具有复杂返回值的函数，该功能非常有用，例如：<br/>
<code>
int (*ptr())[5];//返回指向5维数组的指针<br/>
auto ptr() -> int (*)[5];//也可以这样声明上述函数指针

template&lt;typename T, typename U> auto bar(T t, U u) -> decltype(t - U){}<br/>
bar(2, 2.2);//返回值被推导成double<br/>
</code>
</p>
</li>
</ul>
---
引用<br/>
1. http://www.stroustrup.com/C++11FAQ.html#auto<br/>
2. http://www.cnblogs.com/soaliap/archive/2013/01/08/2851538.html